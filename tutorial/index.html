<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SDL_gpu with Zig: It Begins with a Triangle</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif&family=JetBrains+Mono:wght@400;700&family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0a0a0a;
            --bg-card: #111111;
            --bg-code: #1a1a1a;
            --text: #e8e8e8;
            --text-dim: #888888;
            --accent: #60a5fa;
            --accent-glow: rgba(96, 165, 250, 0.15);
            --border: #2a2a2a;
            --success: #4ade80;
            --error: #f87171;
            --info: #60a5fa;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Space Grotesk', sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            min-height: 100vh;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            opacity: 0.03;
            pointer-events: none;
            z-index: 1000;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 24px;
        }

        header {
            padding: 80px 0 60px;
            border-bottom: 1px solid var(--border);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -20%;
            width: 600px;
            height: 600px;
            background: radial-gradient(circle, var(--accent-glow) 0%, transparent 70%);
            pointer-events: none;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 24px;
        }

        .logo-icon {
            width: 64px;
            height: 64px;
            background: var(--accent);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            font-size: 28px;
            color: var(--bg);
            animation: pulse 3s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        h1 {
            font-family: 'Instrument Serif', serif;
            font-size: clamp(36px, 6vw, 56px);
            font-weight: 400;
            letter-spacing: -1px;
            line-height: 1.1;
            margin-bottom: 16px;
        }

        h1 span {
            color: var(--accent);
        }

        .tagline {
            font-size: 18px;
            color: var(--text-dim);
            max-width: 600px;
        }

        .version-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            padding: 8px 16px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            margin-top: 24px;
        }

        .version-badge::before {
            content: '';
            width: 8px;
            height: 8px;
            background: var(--success);
            border-radius: 50%;
            animation: blink 2s ease-in-out infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        nav {
            position: sticky;
            top: 0;
            background: rgba(10, 10, 10, 0.9);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--border);
            padding: 16px 0;
            z-index: 100;
        }

        nav ul {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            list-style: none;
        }

        nav a {
            display: block;
            padding: 8px 16px;
            color: var(--text-dim);
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            border: 1px solid transparent;
            transition: all 0.2s;
        }

        nav a:hover {
            color: var(--text);
            border-color: var(--border);
            background: var(--bg-card);
        }

        main {
            padding: 60px 0;
        }

        section {
            margin-bottom: 80px;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h2 {
            font-family: 'Instrument Serif', serif;
            font-size: 32px;
            font-weight: 400;
            margin-bottom: 24px;
            margin-top: 48px;
            padding-bottom: 12px;
            border-bottom: 2px solid var(--accent);
            display: inline-block;
        }

        h3 {
            font-size: 20px;
            font-weight: 500;
            margin: 32px 0 16px;
            color: var(--accent);
        }

        p {
            margin-bottom: 16px;
            color: var(--text-dim);
        }

        pre {
            background: var(--bg-code);
            border: 1px solid var(--border);
            padding: 20px 24px;
            overflow-x: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            line-height: 1.7;
            margin: 16px 0 24px;
            position: relative;
        }

        pre::before {
            content: attr(data-lang);
            position: absolute;
            top: 0;
            right: 0;
            padding: 4px 12px;
            background: var(--border);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-dim);
        }

        code {
            font-family: 'JetBrains Mono', monospace;
        }

        :not(pre) > code {
            background: var(--bg-code);
            padding: 2px 8px;
            border: 1px solid var(--border);
            font-size: 0.9em;
            color: var(--accent);
        }

        .kw { color: #c792ea; }
        .fn { color: #82aaff; }
        .str { color: #c3e88d; }
        .num { color: #f78c6c; }
        .cmt { color: #546e7a; font-style: italic; }
        .type { color: #ffcb6b; }
        .builtin { color: #89ddff; }

        ul, ol {
            margin-left: 24px;
            margin-bottom: 16px;
            color: var(--text-dim);
        }

        li {
            margin-bottom: 8px;
        }

        strong {
            color: var(--text);
            font-weight: 600;
        }

        em {
            color: var(--text);
        }

        .tip {
            background: linear-gradient(135deg, var(--accent-glow), transparent);
            border: 1px solid var(--accent);
            border-left: 4px solid var(--accent);
            padding: 16px 20px;
            margin: 24px 0;
            color: var(--text-dim);
        }

        .tip strong {
            color: var(--accent);
        }

        .warning {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.1), transparent);
            border: 1px solid var(--error);
            border-left: 4px solid var(--error);
            padding: 16px 20px;
            margin: 24px 0;
            color: var(--text-dim);
        }

        .warning strong {
            color: var(--error);
        }

        .warning ul {
            margin-top: 12px;
            margin-bottom: 12px;
        }

        .flow-list {
            list-style: none;
            margin-left: 0;
            display: grid;
            gap: 12px;
            margin: 24px 0;
        }

        .flow-list li {
            display: flex;
            align-items: flex-start;
            gap: 16px;
            padding: 16px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            transition: all 0.2s;
        }

        .flow-list li:hover {
            border-color: var(--accent);
            transform: translateX(4px);
        }

        .step-number {
            background: var(--accent);
            color: var(--bg);
            border-radius: 50%;
            min-width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 14px;
        }

        a {
            color: var(--accent);
            text-decoration: none;
            transition: all 0.2s;
        }

        a:hover {
            text-decoration: underline;
        }

        footer {
            border-top: 1px solid var(--border);
            padding: 40px 0;
            text-align: center;
            color: var(--text-dim);
            font-size: 14px;
        }

        .cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px;
            margin: 24px 0;
        }

        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            padding: 20px;
            transition: all 0.3s;
        }

        .card:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
            box-shadow: 0 8px 32px var(--accent-glow);
        }

        .card h4 {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 8px;
            color: var(--text);
        }

        .card p {
            font-size: 14px;
            margin: 0;
        }

        @media (max-width: 768px) {
            header {
                padding: 60px 0 40px;
            }

            nav ul {
                gap: 4px;
            }

            nav a {
                padding: 6px 12px;
                font-size: 13px;
            }

            .flow-list li {
                flex-direction: column;
                gap: 12px;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <div class="logo">
                <div class="logo-icon">Z</div>
                <div>
                    <h1>SDL_gpu with <span>Zig</span></h1>
                    <p class="tagline">It Begins with a Triangle</p>
                </div>
            </div>
            <div class="version-badge">Zig 0.15.2 + SDL3 + Cross-Platform</div>
        </div>
    </header>

    <nav>
        <div class="container">
            <ul>
                <li><a href="#overview">Overview</a></li>
                <li><a href="#setup">Setup</a></li>
                <li><a href="#device">GPU Device</a></li>
                <li><a href="#shaders">Shaders</a></li>
                <li><a href="#triangle">Triangle</a></li>
                <li><a href="#resources">Resources</a></li>
            </ul>
        </div>
    </nav>

    <main>
        <div class="container">
            <section>
                <p>You may think of GPUs as <em>fast</em> black magic, their APIs as spells, and graphics programmers as wizards, and in part you are correct, because a technology too advanced is nothing short of magic. So, in lack of a better introduction, I will try my best to introduce you to this witchcraft&mdash;using <strong>Zig</strong> and the <strong>zig-sdl3</strong> bindings.</p>
            </section>

            <section id="overview">
                <h2>What is SDL_gpu All About?</h2>

                <p>To draw anything on the screen, you need to talk to the GPU, and to talk to the GPU, you need a graphics API. OpenGL is too old, and while it's still enough for many use cases today, it's slowly getting replaced by more <strong>modern</strong> APIs that are faster, have newer features, better designed, better supported or frankly the <strong>only</strong> supported, etc.</p>

                <p>On Linux and Android, you probably want to use <strong>Vulkan</strong>. On Windows, you may want <strong>DirectX12</strong>. On macOS and iOS, you <em>need</em> to use <strong>Metal</strong>. What about consoles? This gets impractical rather quickly.</p>

                <p>Here is where SDL_gpu shines&mdash;it's a "thin layer" above Vulkan / Metal / DirectX12, and more to come in the future. The goal is to write-once-run-everywhere with minimal effort.</p>

                <h3>A Quick Overview</h3>

                <p>It may seem complicated at first. After all, it's not a simple <code>drawTriangle()</code>. However, I promise once you understand why everything is the way it is, it will start to make sense. A million triangles take as much effort as drawing a single one, so please be patient.</p>

                <div class="tip">
                    <strong>Note:</strong> This tutorial uses Zig 0.15.2 and zig-sdl3. The concepts translate directly from the original C/C++ SDL_gpu tutorial, but with Zig's safety and clarity.
                </div>

                <p>The flow will be something like this:</p>

                <ol class="flow-list">
                    <li><span class="step-number">1</span><span>Create a <strong>Device</strong>, which is requesting access to a compatible GPU.</span></li>
                    <li><span class="step-number">2</span><span>Create <strong>Buffers</strong>, which are containers of data on the GPU.</span></li>
                    <li><span class="step-number">3</span><span>Create a <strong>Graphics Pipeline</strong> which tells the GPU how to use these buffers.</span></li>
                    <li><span class="step-number">4</span><span>Acquire a <strong>Command Buffer</strong> to start issuing tasks to the GPU.</span></li>
                    <li><span class="step-number">5</span><span>Fill the buffers with data using <strong>Transfer Buffer</strong> in a <strong>Copy Pass</strong>.</span></li>
                    <li><span class="step-number">6</span><span>Acquire the <strong>Swapchain</strong> texture, or simply the window to draw onto.</span></li>
                    <li><span class="step-number">7</span><span>Finally, issue the <strong>Draw Call</strong> in a <strong>Render Pass</strong>.</span></li>
                </ol>
            </section>

            <section id="setup">
                <h2>Starting with a Blank Window</h2>

                <p>Let's start with a simple Zig program that creates a window. Unlike the C callbacks system, we'll use Zig's straightforward approach:</p>

                <pre data-lang="zig"><code><span class="kw">const</span> std = <span class="builtin">@import</span>(<span class="str">"std"</span>);
<span class="kw">const</span> sdl = <span class="builtin">@import</span>(<span class="str">"sdl3"</span>);

<span class="kw">pub fn</span> <span class="fn">main</span>() !<span class="type">void</span> {
    <span class="cmt">// Initialize SDL3 with video subsystem</span>
    <span class="kw">try</span> sdl.init(.{ .video = <span class="kw">true</span> });
    <span class="kw">defer</span> sdl.quit(.{ .video = <span class="kw">true</span> });

    <span class="cmt">// Create window</span>
    <span class="kw">const</span> window = <span class="kw">try</span> sdl.video.Window.init(
        <span class="str">"Hello, Triangle!"</span>,
        <span class="num">960</span>,
        <span class="num">540</span>,
        .{ .resizable = <span class="kw">true</span> },
    );
    <span class="kw">defer</span> window.deinit();

    std.debug.print(<span class="str">"Window created successfully!\n"</span>, .{});

    <span class="cmt">// Main event loop</span>
    <span class="kw">var</span> running = <span class="kw">true</span>;
    <span class="kw">while</span> (running) {
        <span class="kw">while</span> (sdl.events.poll()) |event| {
            <span class="kw">switch</span> (event) {
                .quit => running = <span class="kw">false</span>,
                .key_down => running = <span class="kw">false</span>,
                <span class="kw">else</span> => {},
            }
        }
    }
}</code></pre>
            </section>

            <section id="device">
                <h2>The GPU Device</h2>

                <p>Before you start drawing anything, the first step is to get access to a GPU device or driver. This project uses <strong>compile-time platform detection</strong> to automatically select the correct shader format:</p>

                <pre data-lang="zig"><code><span class="kw">const</span> std = <span class="builtin">@import</span>(<span class="str">"std"</span>);
<span class="kw">const</span> builtin = <span class="builtin">@import</span>(<span class="str">"builtin"</span>);
<span class="kw">const</span> sdl = <span class="builtin">@import</span>(<span class="str">"sdl3"</span>);

<span class="cmt">// Platform-specific shader configuration</span>
<span class="kw">const</span> is_macos = builtin.os.tag == .macos;
<span class="kw">const</span> ShaderConfig = <span class="kw">if</span> (is_macos) <span class="kw">struct</span> {
    <span class="kw">const</span> format = sdl.gpu.ShaderFormatFlags{ .msl = <span class="kw">true</span> };
    <span class="kw">const</span> vertex_path = <span class="str">"src/shaders/shaders.metal"</span>;
    <span class="kw">const</span> fragment_path = <span class="str">"src/shaders/shaders.metal"</span>;
    <span class="kw">const</span> vertex_entry = <span class="str">"vertex_main"</span>;
    <span class="kw">const</span> fragment_entry = <span class="str">"fragment_main"</span>;
} <span class="kw">else</span> <span class="kw">struct</span> {
    <span class="kw">const</span> format = sdl.gpu.ShaderFormatFlags{ .spirv = <span class="kw">true</span> };
    <span class="kw">const</span> vertex_path = <span class="str">"src/shaders/vertex.spv"</span>;
    <span class="kw">const</span> fragment_path = <span class="str">"src/shaders/fragment.spv"</span>;
    <span class="kw">const</span> vertex_entry = <span class="str">"main"</span>;
    <span class="kw">const</span> fragment_entry = <span class="str">"main"</span>;
};

<span class="cmt">// Create GPU device with platform-appropriate format</span>
<span class="kw">const</span> device = <span class="kw">try</span> sdl.gpu.Device.init(
    ShaderConfig.format,
    <span class="kw">false</span>,  <span class="cmt">// Debug mode</span>
    <span class="kw">null</span>,   <span class="cmt">// Let SDL choose the best driver</span>
);
<span class="kw">defer</span> device.deinit();

<span class="cmt">// Claim the window for GPU rendering</span>
<span class="kw">try</span> device.claimWindow(window);</code></pre>

                <div class="warning">
                    <strong>Platform-Specific Shader Formats</strong>
                    <ul>
                        <li><strong>macOS/iOS:</strong> Metal Shading Language (<code>.msl</code>) - text source files</li>
                        <li><strong>Linux/Windows/Android:</strong> SPIR-V (<code>.spirv</code>) - pre-compiled binary files</li>
                        <li><strong>Windows/Xbox:</strong> DirectX IL (<code>.dxil</code>) - for DirectX 12</li>
                    </ul>
                    <p>Using the wrong format will cause initialization errors!</p>
                </div>

                <div class="tip">
                    <strong>Important:</strong> Zig's <code>defer</code> statement ensures proper cleanup when the scope ends. This is safer than manual cleanup and prevents resource leaks.
                </div>
            </section>

            <section id="shaders">
                <h2>Writing Shaders</h2>

                <p>SDL_gpu requires different shader formats depending on the platform. This project includes both formats for cross-platform support.</p>

                <h3>GLSL Shaders (for Linux/Windows via SPIR-V)</h3>

                <p>Create <code>src/shaders/vertex.vert</code>:</p>

                <pre data-lang="glsl"><code><span class="cmt">#version 450</span>

<span class="kw">layout</span> (location = <span class="num">0</span>) <span class="kw">in</span> <span class="type">vec3</span> a_position;
<span class="kw">layout</span> (location = <span class="num">1</span>) <span class="kw">in</span> <span class="type">vec4</span> a_color;
<span class="kw">layout</span> (location = <span class="num">0</span>) <span class="kw">out</span> <span class="type">vec4</span> v_color;

<span class="kw">void</span> <span class="fn">main</span>() {
    gl_Position = <span class="type">vec4</span>(a_position, <span class="num">1.0</span>);
    v_color = a_color;
}</code></pre>

                <p>Create <code>src/shaders/fragment.frag</code>:</p>

                <pre data-lang="glsl"><code><span class="cmt">#version 450</span>

<span class="kw">layout</span> (location = <span class="num">0</span>) <span class="kw">in</span> <span class="type">vec4</span> v_color;
<span class="kw">layout</span> (location = <span class="num">0</span>) <span class="kw">out</span> <span class="type">vec4</span> FragColor;

<span class="kw">void</span> <span class="fn">main</span>() {
    FragColor = v_color;
}</code></pre>

                <p>Compile to SPIR-V using <code>glslangValidator</code> (or <code>glslc</code>):</p>

                <pre data-lang="bash"><code>glslangValidator -V src/shaders/vertex.vert -o src/shaders/vertex.spv
glslangValidator -V src/shaders/fragment.frag -o src/shaders/fragment.spv</code></pre>

                <h3>Metal Shaders (for macOS/iOS)</h3>

                <p>Create <code>src/shaders/shaders.metal</code>:</p>

                <pre data-lang="metal"><code><span class="cmt">#include &lt;metal_stdlib&gt;</span>
<span class="kw">using namespace</span> metal;

<span class="kw">struct</span> <span class="type">VertexIn</span> {
    float3 position [[<span class="kw">attribute</span>(<span class="num">0</span>)]];
    float4 color [[<span class="kw">attribute</span>(<span class="num">1</span>)]];
};

<span class="kw">struct</span> <span class="type">VertexOut</span> {
    float4 position [[<span class="kw">position</span>]];
    float4 color;
};

<span class="kw">vertex</span> <span class="type">VertexOut</span> <span class="fn">vertex_main</span>(<span class="type">VertexIn</span> in [[<span class="kw">stage_in</span>]]) {
    <span class="type">VertexOut</span> out;
    out.position = float4(in.position, <span class="num">1.0</span>);
    out.color = in.color;
    <span class="kw">return</span> out;
}

<span class="kw">fragment</span> float4 <span class="fn">fragment_main</span>(<span class="type">VertexOut</span> in [[<span class="kw">stage_in</span>]]) {
    <span class="kw">return</span> in.color;
}</code></pre>

                <h3>Loading Shaders in Zig</h3>

                <p>The shader loading code uses the compile-time <code>ShaderConfig</code> to load the correct files:</p>

                <pre data-lang="zig"><code><span class="cmt">// Load shader code (text for Metal, binary for SPIR-V)</span>
<span class="kw">const</span> vertex_code = <span class="kw">try</span> std.fs.cwd().readFileAlloc(
    allocator,
    ShaderConfig.vertex_path,
    <span class="num">1024</span> * <span class="num">1024</span>,
);
<span class="kw">defer</span> allocator.free(vertex_code);

<span class="kw">const</span> fragment_code = <span class="kw">if</span> (is_macos)
    vertex_code  <span class="cmt">// Metal uses same file for both shaders</span>
<span class="kw">else</span>
    <span class="kw">try</span> std.fs.cwd().readFileAlloc(
        allocator,
        ShaderConfig.fragment_path,
        <span class="num">1024</span> * <span class="num">1024</span>,
    );
<span class="kw">defer if</span> (!is_macos) allocator.free(fragment_code);

<span class="cmt">// Create shaders</span>
<span class="kw">const</span> vertex_shader = <span class="kw">try</span> device.createShader(.{
    .code = vertex_code,
    .entry_point = ShaderConfig.vertex_entry,
    .format = ShaderConfig.format,
    .stage = .vertex,
    .num_samplers = <span class="num">0</span>,
    .num_storage_buffers = <span class="num">0</span>,
    .num_storage_textures = <span class="num">0</span>,
    .num_uniform_buffers = <span class="num">0</span>,
});
<span class="kw">defer</span> device.releaseShader(vertex_shader);

<span class="kw">const</span> fragment_shader = <span class="kw">try</span> device.createShader(.{
    .code = fragment_code,
    .entry_point = ShaderConfig.fragment_entry,
    .format = ShaderConfig.format,
    .stage = .fragment,
    .num_samplers = <span class="num">0</span>,
    .num_storage_buffers = <span class="num">0</span>,
    .num_storage_textures = <span class="num">0</span>,
    .num_uniform_buffers = <span class="num">0</span>,
});
<span class="kw">defer</span> device.releaseShader(fragment_shader);</code></pre>
            </section>

            <section id="triangle">
                <h2>Drawing a Triangle</h2>

                <p>Now for the exciting part&mdash;actually drawing geometry. This requires:</p>

                <ol>
                    <li>Creating GPU buffers with vertex data</li>
                    <li>Uploading data via transfer buffers</li>
                    <li>Creating a graphics pipeline</li>
                    <li>Issuing draw calls in a render pass</li>
                </ol>

                <h3>Creating Vertex Buffers</h3>

                <pre data-lang="zig"><code><span class="cmt">// Vertex structure: position (vec3) + color (vec4)</span>
<span class="kw">const</span> Vertex = <span class="kw">struct</span> {
    x: <span class="type">f32</span>, y: <span class="type">f32</span>, z: <span class="type">f32</span>,     <span class="cmt">// Position</span>
    r: <span class="type">f32</span>, g: <span class="type">f32</span>, b: <span class="type">f32</span>, a: <span class="type">f32</span>, <span class="cmt">// Color</span>
};

<span class="cmt">// Triangle vertices in NDC (Normalized Device Coordinates)</span>
<span class="cmt">// (0,0) is center, (1,1) is top-right, (-1,-1) is bottom-left</span>
<span class="kw">const</span> vertices = [_]Vertex{
    .{ .x = <span class="num">0.0</span>,  .y = <span class="num">0.5</span>,  .z = <span class="num">0.0</span>, .r = <span class="num">1.0</span>, .g = <span class="num">0.0</span>, .b = <span class="num">0.0</span>, .a = <span class="num">1.0</span> }, <span class="cmt">// Top (red)</span>
    .{ .x = <span class="num">-0.5</span>, .y = <span class="num">-0.5</span>, .z = <span class="num">0.0</span>, .r = <span class="num">1.0</span>, .g = <span class="num">1.0</span>, .b = <span class="num">0.0</span>, .a = <span class="num">1.0</span> }, <span class="cmt">// Bottom-left (yellow)</span>
    .{ .x = <span class="num">0.5</span>,  .y = <span class="num">-0.5</span>, .z = <span class="num">0.0</span>, .r = <span class="num">1.0</span>, .g = <span class="num">0.0</span>, .b = <span class="num">1.0</span>, .a = <span class="num">1.0</span> }, <span class="cmt">// Bottom-right (magenta)</span>
};

<span class="cmt">// Create vertex buffer on GPU</span>
<span class="kw">const</span> vertex_buffer = <span class="kw">try</span> device.createBuffer(.{
    .usage = .{ .vertex = <span class="kw">true</span> },
    .size = <span class="builtin">@sizeOf</span>(<span class="builtin">@TypeOf</span>(vertices)),
});
<span class="kw">defer</span> device.releaseBuffer(vertex_buffer);</code></pre>

                <h3>Uploading Data to GPU</h3>

                <pre data-lang="zig"><code><span class="cmt">// Create transfer buffer</span>
<span class="kw">const</span> transfer_buffer = <span class="kw">try</span> device.createTransferBuffer(.{
    .usage = .upload,
    .size = <span class="builtin">@sizeOf</span>(<span class="builtin">@TypeOf</span>(vertices)),
});
<span class="kw">defer</span> device.releaseTransferBuffer(transfer_buffer);

<span class="cmt">// Map and fill transfer buffer</span>
<span class="kw">const</span> data = <span class="kw">try</span> device.mapTransferBuffer(transfer_buffer, <span class="kw">false</span>);
<span class="kw">const</span> vertex_data = <span class="builtin">@as</span>([*]Vertex, <span class="builtin">@ptrCast</span>(<span class="builtin">@alignCast</span>(data)));
<span class="kw">for</span> (vertices, <span class="num">0</span>..) |v, i| {
    vertex_data[i] = v;
}
device.unmapTransferBuffer(transfer_buffer);

<span class="cmt">// Upload to GPU using copy pass</span>
<span class="kw">const</span> upload_cmd = <span class="kw">try</span> device.acquireCommandBuffer();
{
    <span class="kw">const</span> copy_pass = upload_cmd.beginCopyPass();
    <span class="kw">defer</span> copy_pass.end();

    copy_pass.uploadToBuffer(
        .{ .transfer_buffer = transfer_buffer, .offset = <span class="num">0</span> },
        .{ .buffer = vertex_buffer, .offset = <span class="num">0</span>, .size = <span class="builtin">@sizeOf</span>(<span class="builtin">@TypeOf</span>(vertices)) },
        <span class="kw">false</span>,
    );
}
<span class="kw">try</span> upload_cmd.submit();</code></pre>

                <h3>Creating the Graphics Pipeline</h3>

                <pre data-lang="zig"><code><span class="cmt">// Vertex buffer description</span>
<span class="kw">const</span> vertex_buffer_desc = sdl.gpu.VertexBufferDescription{
    .slot = <span class="num">0</span>,
    .pitch = <span class="builtin">@sizeOf</span>(Vertex),
    .input_rate = .vertex,
    .instance_step_rate = <span class="num">0</span>,
};

<span class="cmt">// Vertex attributes</span>
<span class="kw">const</span> vertex_attributes = [_]sdl.gpu.VertexAttribute{
    .{ .location = <span class="num">0</span>, .buffer_slot = <span class="num">0</span>, .format = .f32x3, .offset = <span class="num">0</span> },
    .{ .location = <span class="num">1</span>, .buffer_slot = <span class="num">0</span>, .format = .f32x4, .offset = <span class="builtin">@offsetOf</span>(Vertex, <span class="str">"r"</span>) },
};

<span class="cmt">// Color target description</span>
<span class="kw">const</span> color_target_desc = sdl.gpu.ColorTargetDescription{
    .format = <span class="kw">try</span> device.getSwapchainTextureFormat(window),
    .blend_state = .{
        .enable_blend = <span class="kw">true</span>,
        .color_blend = .add,
        .alpha_blend = .add,
        .source_color = .src_alpha,
        .source_alpha = .src_alpha,
        .destination_color = .one_minus_src_alpha,
        .destination_alpha = .one_minus_src_alpha,
        .enable_color_write_mask = <span class="kw">true</span>,
        .color_write_mask = .{ .red = <span class="kw">true</span>, .green = <span class="kw">true</span>, .blue = <span class="kw">true</span>, .alpha = <span class="kw">true</span> },
    },
};

<span class="cmt">// Create graphics pipeline</span>
<span class="kw">const</span> pipeline = <span class="kw">try</span> device.createGraphicsPipeline(.{
    .vertex_shader = vertex_shader,
    .fragment_shader = fragment_shader,
    .primitive_type = .triangle_list,
    .vertex_input_state = .{
        .vertex_buffer_descriptions = &[_]sdl.gpu.VertexBufferDescription{vertex_buffer_desc},
        .vertex_attributes = &vertex_attributes,
    },
    .target_info = .{
        .color_target_descriptions = &[_]sdl.gpu.ColorTargetDescription{color_target_desc},
        .depth_stencil_format = <span class="kw">null</span>,
    },
});
<span class="kw">defer</span> device.releaseGraphicsPipeline(pipeline);</code></pre>

                <h3>The Render Loop</h3>

                <pre data-lang="zig"><code><span class="kw">var</span> running = <span class="kw">true</span>;
<span class="kw">while</span> (running) {
    <span class="kw">while</span> (sdl.events.poll()) |event| {
        <span class="kw">switch</span> (event) {
            .quit, .key_down => running = <span class="kw">false</span>,
            <span class="kw">else</span> => {},
        }
    }

    <span class="kw">const</span> cmd = <span class="kw">try</span> device.acquireCommandBuffer();

    <span class="kw">const</span> swapchain_texture_opt, _, _ = <span class="kw">try</span> cmd.waitAndAcquireSwapchainTexture(window);
    <span class="kw">const</span> swapchain_texture = swapchain_texture_opt <span class="kw">orelse</span> {
        <span class="kw">try</span> cmd.submit();
        <span class="kw">continue</span>;
    };

    <span class="kw">const</span> color_target = sdl.gpu.ColorTargetInfo{
        .texture = swapchain_texture,
        .clear_color = .{ .r = <span class="num">0.94</span>, .g = <span class="num">0.94</span>, .b = <span class="num">0.94</span>, .a = <span class="num">1.0</span> },
        .load = .clear,
        .store = .store,
    };

    {
        <span class="kw">const</span> pass = cmd.beginRenderPass(&.{color_target}, <span class="kw">null</span>);
        <span class="kw">defer</span> pass.end();

        pass.bindGraphicsPipeline(pipeline);
        pass.bindVertexBuffers(<span class="num">0</span>, &[_]sdl.gpu.BufferBinding{.{
            .buffer = vertex_buffer,
            .offset = <span class="num">0</span>,
        }});
        pass.drawPrimitives(<span class="num">3</span>, <span class="num">1</span>, <span class="num">0</span>, <span class="num">0</span>);
    }

    <span class="kw">try</span> cmd.submit();
    sdl.timer.delayMilliseconds(<span class="num">16</span>); <span class="cmt">// ~60 FPS</span>
}</code></pre>

                <p>Congratulations! You should now see a beautiful colored triangle on your screen!</p>
            </section>

            <section>
                <h2>Building Your Project</h2>

                <pre data-lang="bash"><code><span class="cmt"># Build the project</span>
zig build

<span class="cmt"># Run the application</span>
zig build run</code></pre>

                <div class="tip">
                    <strong>Cross-Platform:</strong> The same codebase compiles and runs on both macOS (Metal) and Linux (Vulkan) without any changes!
                </div>
            </section>

            <section id="resources">
                <h2>Next Steps</h2>

                <div class="cards">
                    <div class="card">
                        <h4>Textures & Samplers</h4>
                        <p>Learn to load and apply textures to your geometry.</p>
                    </div>
                    <div class="card">
                        <h4>3D Transformations</h4>
                        <p>Add matrices for model, view, and projection transforms.</p>
                    </div>
                    <div class="card">
                        <h4>Depth Testing</h4>
                        <p>Enable depth buffers for proper 3D scene rendering.</p>
                    </div>
                    <div class="card">
                        <h4>Compute Shaders</h4>
                        <p>Harness GPU compute for parallel processing.</p>
                    </div>
                </div>

                <h3>Resources</h3>

                <ul>
                    <li><a href="https://ziglang.org/documentation/master/">Zig Documentation</a></li>
                    <li><a href="https://github.com/libsdl-org/SDL">SDL3 on GitHub</a></li>
                    <li><a href="https://wiki.libsdl.org/SDL3/CategoryGPU">SDL_gpu API Reference</a></li>
                    <li><a href="https://github.com/TheSpydog/SDL_gpu_examples">SDL_gpu Examples</a></li>
                    <li><a href="https://learnopengl.com/">LearnOpenGL</a> (concepts translate to SDL_gpu)</li>
                    <li><a href="https://vulkan-tutorial.com/">Vulkan Tutorial</a> (for deeper understanding)</li>
                </ul>

                <div class="tip">
                    <strong>Note on Platforms:</strong> SDL_gpu currently supports Vulkan (Linux/Android/Windows), Metal (macOS/iOS), and DirectX 12 (Windows/Xbox). WebGPU support is planned for web deployment.
                </div>
            </section>

            <section>
                <h2>Conclusion</h2>

                <p>You've successfully created your first GPU-accelerated graphics program using Zig and SDL_gpu! While there was significant setup, you now understand the fundamental concepts of modern graphics programming:</p>

                <ul>
                    <li>GPU device initialization with platform detection</li>
                    <li>Buffer management and data transfer</li>
                    <li>Cross-platform shader compilation (Metal + SPIR-V)</li>
                    <li>Pipeline creation and render passes</li>
                    <li>Draw calls with vertex buffers</li>
                </ul>

                <p>The journey from here involves building on these fundamentals. Every complex 3D scene, game, or visualization tool uses these same building blocks. With Zig's safety features and SDL_gpu's cross-platform abstraction, you have a solid foundation for creating high-performance graphics applications.</p>

                <p><strong>Happy coding, and may your triangles always render beautifully!</strong></p>
            </section>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>Adapted from the original SDL_gpu C/C++ tutorial for Zig developers</p>
            <p>SDL_gpu &copy; SDL Team | Zig &copy; Zig Software Foundation</p>
        </div>
    </footer>
</body>
</html>
